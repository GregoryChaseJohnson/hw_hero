<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <style>
    /* 1) Force a specific monospace font, consistent size, line-height */
    body {
      background-color: hsl(36, 14%, 10%);
      color: #d9e4ee;
      font-family: "Courier New", Courier, monospace;
      font-size: 16px;
      line-height: 1.2;
      margin: 20px;
    }

    .sentence-container {
      position: relative;
      margin-bottom: 2rem; /* Space between sentences */
    }

    .final-line {
      display: inline-block;
      white-space: nowrap;
      position: relative;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    .annotated-line {
      position: absolute;
      top: -1rem;  /* Position annotated text just above the final line */
      left: 0;
      white-space: nowrap;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    .token {
      white-space: pre;
      margin-right: 0.1rem;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    .equal { color: #fdf8f8f3; }
    .replace, .delete { color: #f781fe; }
    .corrected, .insert { color: #00cc7a; }

    .corrected-char {
      position: absolute; /* We'll position each char individually */
      white-space: pre;
      color: #28ffa5;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <script>
    // 1) Fetch data from /data.json
    async function fetchData() {
      const response = await fetch("/data.json");
      if (!response.ok) {
        console.error("Failed to fetch /data.json");
        return null;
      }
      return await response.json();
    }

    /**
     * Render a single sentence:
     *   - "final_sentence_tokens" is an array of tokens for the bottom line.
     *   - "blocks" is an array of objects each containing:
     *        final_start, final_end, replaced_text,
     *        annotated_start, annotated_end, corrected_text, etc.
     */
    function renderSentence(sentence) {
      const container = document.createElement("div");
      container.className = "sentence-container";

      const finalLine = document.createElement("div");
      finalLine.className = "final-line";

      const annotatedLine = document.createElement("div");
      annotatedLine.className = "annotated-line";

      container.appendChild(finalLine);
      container.appendChild(annotatedLine);

      // 2) Render the bottom (final) line tokens
      sentence.final_sentence_tokens.forEach((token) => {
        const span = document.createElement("span");
        span.className = `token ${token.type}`;
        // Convert ASCII space to non-breaking space for visual alignment
        span.textContent = (token.char === ' ') ? '\u00A0' : token.char;
        span.dataset.index = token.index;
        finalLine.appendChild(span);
      });

      // After finalLine is in the DOM, measure each token's bounding box
      requestAnimationFrame(() => {
        // DOM nodes for final tokens
        const tokenEls = finalLine.querySelectorAll(".token");
        const rects = Array.from(tokenEls).map(el => el.getBoundingClientRect());
        const containerRect = container.getBoundingClientRect();

        /*
         * 3) Render each block's corrected text per character:
         *    We assume the length of corrected_text is about the same
         *    or less/more than the replaced region, so we match them
         *    character-by-character as best we can.
         */
        sentence.blocks.forEach((block) => {
          const correctedString = block.corrected_text || "";
          const correctedChars = correctedString.split("");

          // For each character in "corrected_text", we attempt to place it
          // above the corresponding final token [final_start + i].
          correctedChars.forEach((char, i) => {
            // The final index we want to align with:
            const finalIdx = block.final_start + i;

            // If finalIdx is out of range, we might skip or do fallback logic
            if (!rects[finalIdx]) {
              return; // or handle leftover chars differently
            }

            const finalTokenBox = rects[finalIdx];

            const correctedSpan = document.createElement("span");
            correctedSpan.className = "corrected-char";
            correctedSpan.textContent = (char === ' ') ? '\u00A0' : char;

            // Position precisely above the final token
            correctedSpan.style.left = `${finalTokenBox.left - containerRect.left}px`;
            correctedSpan.style.top  = `${finalTokenBox.top  - containerRect.top  - 8}px`;

            annotatedLine.appendChild(correctedSpan);
          });
        });
      });

      return container;
    }

    // 4) Render all sentences
    async function renderApp() {
      const app = document.getElementById("app");
      app.innerHTML = ""; // Clear

      const data = await fetchData();
      if (!data) return;

      // Suppose data has "sentences"
      data.sentences.forEach(sentence => {
        const sentenceEl = renderSentence(sentence);
        app.appendChild(sentenceEl);
      });
    }

    renderApp();
    window.addEventListener("resize", renderApp);
  </script>
</body>
</html>
